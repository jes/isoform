<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDF CAD</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
        }
        canvas {
            display: block;
            flex: 1;
            width: 50vw;
            height: 100vh;
        }
        #ui-panel {
            width: 200px;
            background-color: rgba(30, 30, 40, 0.8);
            color: white;
            padding: 15px;
            font-family: Arial, sans-serif;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        .indented {
            margin-left: 20px;
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div id="ui-panel">
        <div class="control-group">
            <h3>Objects</h3>
            <label><input type="checkbox" id="showSphere" checked> Sphere</label>
            <label class="indented"><input type="checkbox" id="subtractSphere"> Subtractive</label>
            <label class="indented"><input type="checkbox" id="thicknessSphere"> Thickness</label>
            
            <label><input type="checkbox" id="showBox" checked> Box</label>
            <label class="indented"><input type="checkbox" id="subtractBox"> Subtractive</label>
            <label class="indented"><input type="checkbox" id="thicknessBox"> Thickness</label>
            
            <label><input type="checkbox" id="showTorus" checked> Torus</label>
            <label class="indented"><input type="checkbox" id="subtractTorus"> Subtractive</label>
            <label class="indented"><input type="checkbox" id="thicknessTorus"> Thickness</label>
        </div>
        
        <div class="control-group">
            <h3>Parameters</h3>
            <label for="smoothness">Blend Smoothness: <span id="smoothnessValue">0.5</span></label>
            <input type="range" id="smoothness" min="0.00" max="2.0" step="0.01" value="0.5">
        </div>
        
        <div class="control-group">
            <h3>Navigation</h3>
            <p><strong>Rotate:</strong> Click and drag</p>
            <p><strong>Pan:</strong> Shift + drag</p>
            <p><strong>Zoom:</strong> Mouse wheel</p>
        </div>
    </div>

    <!-- Vertex shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aVertexPosition;
        
        void main() {
            gl_Position = aVertexPosition;
        }
    </script>

    <!-- Fragment shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform vec2 uResolution;
        uniform float uTime;
        uniform vec3 uCameraPosition;
        uniform vec3 uCameraTarget;
        uniform float uCameraZoom;
        uniform float uRotationX;
        uniform float uRotationY;
        
        // 3D SDF primitives
        float sdSphere(vec3 p, float r) {
            return length(p) - r;
        }
        
        float sdBox(vec3 p, vec3 b) {
            vec3 d = abs(p) - b;
            return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
        }
        
        float sdTorus(vec3 p, vec2 t) {
            vec2 q = vec2(length(p.xz) - t.x, p.y);
            return length(q) - t.y;
        }
        
        // SDF operations
        float opUnion(float d1, float d2) { return min(d1, d2); }
        float opSubtraction(float d1, float d2) { return max(d1, -d2); }
        float opIntersection(float d1, float d2) { return max(d1, d2); }
        
        // Thickness operation - creates a shell of thickness t around the object
        float opThickness(float d, float t) {
            return abs(d) - t;
        }
        
        // Smooth blend operations
        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) - k * h * (1.0 - h);
        }
        float opSmoothSubtraction(float d1, float d2, float k) {
            float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
            return mix(d1, -d2, h) + k * h * (1.0 - h);
        }
        
        // Apply rotation to a point
        vec3 rotatePoint(vec3 p) {
            // Rotate around Y axis
            float cosY = cos(uRotationY);
            float sinY = sin(uRotationY);
            p = vec3(
                p.x * cosY - p.z * sinY,
                p.y,
                p.x * sinY + p.z * cosY
            );
            
            // Rotate around X axis
            float cosX = cos(uRotationX);
            float sinX = sin(uRotationX);
            p = vec3(
                p.x,
                p.y * cosX - p.z * sinX,
                p.y * sinX + p.z * cosX
            );
            
            return p;
        }
        
        // Scene description
        float map(vec3 p) {
            // Apply rotation to the point (effectively rotating the scene)
            p = rotatePoint(p);
            
            // Animate objects
            vec3 spherePos = p - vec3(sin(uTime) * 1.5, cos(uTime * 0.5), 0.0);
            vec3 boxPos = p - vec3(0.0, sin(uTime) * 0.5, cos(uTime) * 1.5);
            vec3 torusPos = p - vec3(cos(uTime * 0.7) * 1.0, 0.0, sin(uTime * 0.5) * 1.0);
            
            // Create objects
            float sphere = sdSphere(spherePos, 1.0);
            float box = sdBox(boxPos, vec3(0.75));
            float torus = sdTorus(torusPos, vec2(1.0, 0.3));
            
            // Combine objects
            float scene = opSmoothUnion(sphere, box, 0.5);
            scene = opSmoothUnion(scene, torus, 0.5);
            // Add ground plane
            
            return scene;
        }
        
        // Calculate normal at a point
        vec3 calcNormal(vec3 p) {
            const float eps = 0.001;
            const vec2 h = vec2(eps, 0.0);
            return normalize(vec3(
                map(p + h.xyy) - map(p - h.xyy),
                map(p + h.yxy) - map(p - h.yxy),
                map(p + h.yyx) - map(p - h.yyx)
            ));
        }
        
        // Ray marching
        float rayMarch(vec3 ro, vec3 rd) {
            float t = 0.0;
            for (int i = 0; i < 100; i++) {
                vec3 p = ro + rd * t;
                float d = map(p);
                if (d < 0.001 || t > 20.0) break;
                t += d;
            }
            return t;
        }
        
        void main() {
            // Normalized coordinates (0.0 to 1.0)
            vec2 uv = gl_FragCoord.xy / uResolution.xy;
            
            // Convert to centered coordinates (-1.0 to 1.0)
            vec2 p = (2.0 * uv - 1.0);
            // Correct aspect ratio
            p.x *= uResolution.x / uResolution.y;
            
            // Camera setup
            vec3 ro = uCameraPosition; // Ray origin (camera position)
            vec3 target = uCameraTarget; // Look at point
            
            // Camera frame
            vec3 forward = normalize(target - ro);
            vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
            vec3 up = cross(forward, right);
            
            // Apply zoom
            float zoom = uCameraZoom;
            
            // Ray direction using camera frame
            vec3 rd = normalize(forward + p.x * right * zoom + p.y * up * zoom);
            
            // Ray march to find distance
            float t = rayMarch(ro, rd);
            
            // Default background color
            vec3 color = vec3(0.1, 0.1, 0.2);
            
            // If we hit something
            if (t < 20.0) {
                // Calculate hit position and normal
                vec3 pos = ro + rd * t;
                vec3 normal = calcNormal(pos);
                
                // Simple lighting
                vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Base color based on normal
                vec3 objColor = 0.5 + 0.5 * normal;
                
                // Add some color variation based on position
                objColor *= 0.8 + 0.2 * vec3(
                    0.5 + 0.5 * sin(pos.x * 2.0 + uTime),
                    0.5 + 0.5 * sin(pos.y * 2.0 + uTime * 0.7),
                    0.5 + 0.5 * sin(pos.z * 2.0 + uTime * 0.5)
                );
                
                // Apply lighting
                color = objColor * (0.2 + 0.8 * diff);
                
                // Add ambient occlusion
                float ao = 1.0 - (1.0 / (1.0 + t * 0.1));
                color *= ao;
            }
            
            // Apply gamma correction
            color = pow(color, vec3(0.4545));
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // Initialize WebGL when the page loads
        window.onload = function() {
            // Extract core functionality into separate objects/functions
            
            // WebGL setup and management
            const renderer = {
                canvas: document.getElementById('glCanvas'),
                gl: null,
                programInfo: null,
                positionBuffer: null,
                startTime: Date.now(),
                
                init: function() {
                    this.gl = this.canvas.getContext('webgl');
                    if (!this.gl) {
                        alert('Unable to initialize WebGL. Your browser may not support it.');
                        return false;
                    }
                    
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());
                    
                    // Create buffer for full-screen quad
                    const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];
                    this.positionBuffer = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
                    
                    return true;
                },
                
                resizeCanvas: function() {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                },
                
                compileShader: function(source, type) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);

                    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                        console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                        this.gl.deleteShader(shader);
                        return null;
                    }
                    return shader;
                },
                
                createShaderProgram: function(vsSource, fsSource) {
                    const vertexShader = this.compileShader(vsSource, this.gl.VERTEX_SHADER);
                    const fragmentShader = this.compileShader(fsSource, this.gl.FRAGMENT_SHADER);

                    const program = this.gl.createProgram();
                    this.gl.attachShader(program, vertexShader);
                    this.gl.attachShader(program, fragmentShader);
                    this.gl.linkProgram(program);

                    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                        console.error('Program linking error:', this.gl.getProgramInfoLog(program));
                        return null;
                    }
                    
                    // Set up program info
                    this.programInfo = {
                        program: program,
                        attribLocations: {
                            vertexPosition: this.gl.getAttribLocation(program, 'aVertexPosition'),
                        },
                        uniformLocations: {
                            resolution: this.gl.getUniformLocation(program, 'uResolution'),
                            time: this.gl.getUniformLocation(program, 'uTime'),
                            cameraPosition: this.gl.getUniformLocation(program, 'uCameraPosition'),
                            cameraTarget: this.gl.getUniformLocation(program, 'uCameraTarget'),
                            cameraZoom: this.gl.getUniformLocation(program, 'uCameraZoom'),
                            rotationX: this.gl.getUniformLocation(program, 'uRotationX'),
                            rotationY: this.gl.getUniformLocation(program, 'uRotationY')
                        },
                    };
                    
                    return program;
                },
                
                render: function() {
                    const currentTime = (Date.now() - this.startTime) / 1000;
                    
                    // Clear the canvas
                    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    
                    // Use our shader program
                    this.gl.useProgram(this.programInfo.program);
                    
                    // Set up vertex attribute
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                    this.gl.vertexAttribPointer(
                        this.programInfo.attribLocations.vertexPosition,
                        2, this.gl.FLOAT, false, 0, 0
                    );
                    this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);
                    
                    // Set uniforms
                    this.gl.uniform2f(this.programInfo.uniformLocations.resolution, this.canvas.width, this.canvas.height);
                    this.gl.uniform1f(this.programInfo.uniformLocations.time, currentTime);
                    this.gl.uniform3fv(this.programInfo.uniformLocations.cameraPosition, camera.position);
                    this.gl.uniform3fv(this.programInfo.uniformLocations.cameraTarget, camera.target);
                    this.gl.uniform1f(this.programInfo.uniformLocations.cameraZoom, camera.zoom);
                    this.gl.uniform1f(this.programInfo.uniformLocations.rotationX, camera.rotationX);
                    this.gl.uniform1f(this.programInfo.uniformLocations.rotationY, camera.rotationY);
                    
                    // Draw the square (as triangle strip)
                    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                }
            };
            
            // Camera controls
            const camera = {
                position: [0.0, 0.0, -5.0],
                target: [0.0, 0.0, 0.0],
                zoom: 1.0,
                rotationX: 0.0,
                rotationY: 0.0,
                isDragging: false,
                lastMouseX: 0,
                lastMouseY: 0,
                rotationSpeed: 0.01,
                zoomSpeed: 0.1,
                panSpeed: 0.01,
                
                init: function(canvas) {
                    // Mouse event handlers
                    canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                    canvas.addEventListener('mouseup', () => this.onMouseUp());
                    canvas.addEventListener('mouseleave', () => this.onMouseLeave());
                    canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                    canvas.addEventListener('wheel', (e) => this.onWheel(e));
                },
                
                onMouseDown: function(e) {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                },
                
                onMouseUp: function() {
                    this.isDragging = false;
                },
                
                onMouseLeave: function() {
                    this.isDragging = false;
                },
                
                onMouseMove: function(e) {
                    if (!this.isDragging) return;
                    
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    if (e.shiftKey) {
                        // Pan camera in screen space
                        const panX = -deltaX * this.panSpeed;
                        const panY = deltaY * this.panSpeed;
                        
                        this.target[0] += panX;
                        this.target[1] += panY;
                        this.position[0] += panX;
                        this.position[1] += panY;
                    } else {
                        // Rotate the scene
                        this.rotationY += deltaX * this.rotationSpeed;
                        this.rotationX += deltaY * this.rotationSpeed;
                    }
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                },
                
                onWheel: function(e) {
                    e.preventDefault();
                    
                    // Adjust zoom based on wheel direction
                    const zoomDelta = e.deltaY * this.zoomSpeed * 0.01;
                    this.zoom += zoomDelta;
                    
                    // Clamp zoom to reasonable values
                    this.zoom = Math.max(0.1, Math.min(2.0, this.zoom));
                }
            };
            
            // Scene configuration
            const scene = {
                showSphere: document.getElementById('showSphere'),
                showBox: document.getElementById('showBox'),
                showTorus: document.getElementById('showTorus'),
                subtractSphere: document.getElementById('subtractSphere'),
                subtractBox: document.getElementById('subtractBox'),
                subtractTorus: document.getElementById('subtractTorus'),
                thicknessSphere: document.getElementById('thicknessSphere'),
                thicknessBox: document.getElementById('thicknessBox'),
                thicknessTorus: document.getElementById('thicknessTorus'),
                smoothnessSlider: document.getElementById('smoothness'),
                smoothnessValue: document.getElementById('smoothnessValue'),
                currentSmoothness: 0.5,
                needsRecompile: false,
                
                init: function() {
                    // Initialize smoothness value
                    this.currentSmoothness = parseFloat(this.smoothnessSlider.value);
                    
                    // Add event listeners
                    this.showSphere.addEventListener('change', () => this.needsRecompile = true);
                    this.showBox.addEventListener('change', () => this.needsRecompile = true);
                    this.showTorus.addEventListener('change', () => this.needsRecompile = true);
                    this.subtractSphere.addEventListener('change', () => this.needsRecompile = true);
                    this.subtractBox.addEventListener('change', () => this.needsRecompile = true);
                    this.subtractTorus.addEventListener('change', () => this.needsRecompile = true);
                    this.thicknessSphere.addEventListener('change', () => this.needsRecompile = true);
                    this.thicknessBox.addEventListener('change', () => this.needsRecompile = true);
                    this.thicknessTorus.addEventListener('change', () => this.needsRecompile = true);
                    
                    this.smoothnessSlider.addEventListener('input', () => {
                        this.currentSmoothness = parseFloat(this.smoothnessSlider.value);
                        this.smoothnessValue.textContent = this.currentSmoothness.toFixed(2);
                        this.needsRecompile = true;
                    });
                },
                
                generateShaderCode: function() {
                    if (!this.needsRecompile) return null;
                    
                    // Get the original shader source
                    let originalSource = document.getElementById('fragment-shader').text;
                    
                    // Find the scene combination part
                    const sceneStartMarker = "// Combine objects";
                    const sceneEndMarker = "// Add ground plane";
                    
                    let startIndex = originalSource.indexOf(sceneStartMarker);
                    let endIndex = originalSource.indexOf(sceneEndMarker);
                    
                    if (startIndex === -1 || endIndex === -1) return null;
                    
                    // Skip to the end of the start marker line
                    startIndex = originalSource.indexOf('\n', startIndex) + 1;
                    
                    // Build the new scene combination code
                    let newSceneCode = "            // Combine objects\n";
                    
                    // Check if we have any positive objects
                    const hasPositiveObjects = 
                        (this.showSphere.checked && !this.subtractSphere.checked) || 
                        (this.showBox.checked && !this.subtractBox.checked) || 
                        (this.showTorus.checked && !this.subtractTorus.checked);
                    
                    // Check if we have any subtractive objects
                    const hasSubtractiveObjects = 
                        (this.showSphere.checked && this.subtractSphere.checked) || 
                        (this.showBox.checked && this.subtractBox.checked) || 
                        (this.showTorus.checked && this.subtractTorus.checked);
                    
                    // If no objects are selected at all
                    if (!this.showSphere.checked && !this.showBox.checked && !this.showTorus.checked) {
                        newSceneCode += "            float scene = 1000.0; // No objects selected\n";
                    } 
                    // If we only have subtractive objects, create a base sphere
                    else if (!hasPositiveObjects && hasSubtractiveObjects) {
                        newSceneCode += "            float scene = 10.0; // Base for subtractive objects\n";
                        
                        // Add all subtractive objects
                        if (this.showSphere.checked && this.subtractSphere.checked) {
                            newSceneCode += `            scene = opSmoothSubtraction(scene, sphere, ${this.currentSmoothness.toFixed(2)});\n`;
                        }
                        
                        if (this.showBox.checked && this.subtractBox.checked) {
                            newSceneCode += `            scene = opSmoothSubtraction(scene, box, ${this.currentSmoothness.toFixed(2)});\n`;
                        }
                        
                        if (this.showTorus.checked && this.subtractTorus.checked) {
                            newSceneCode += `            scene = opSmoothSubtraction(scene, torus, ${this.currentSmoothness.toFixed(2)});\n`;
                        }
                    } 
                    // We have at least one positive object
                    else {
                        // Initialize with the first positive object
                        let sceneInitialized = false;
                        
                        // First pass: add all positive objects
                        if (this.showSphere.checked && !this.subtractSphere.checked) {
                            let sphereObj = "sphere";
                            if (this.thicknessSphere.checked) {
                                sphereObj = `opThickness(sphere, 0.1)`;
                            }
                            
                            if (!sceneInitialized) {
                                newSceneCode += `            float scene = ${sphereObj};\n`;
                                sceneInitialized = true;
                            } else {
                                newSceneCode += `            scene = opSmoothUnion(scene, ${sphereObj}, ${this.currentSmoothness.toFixed(2)});\n`;
                            }
                        }
                        
                        if (this.showBox.checked && !this.subtractBox.checked) {
                            let boxObj = "box";
                            if (this.thicknessBox.checked) {
                                boxObj = `opThickness(box, 0.1)`;
                            }
                            
                            if (!sceneInitialized) {
                                newSceneCode += `            float scene = ${boxObj};\n`;
                                sceneInitialized = true;
                            } else {
                                newSceneCode += `            scene = opSmoothUnion(scene, ${boxObj}, ${this.currentSmoothness.toFixed(2)});\n`;
                            }
                        }
                        
                        if (this.showTorus.checked && !this.subtractTorus.checked) {
                            let torusObj = "torus";
                            if (this.thicknessTorus.checked) {
                                torusObj = `opThickness(torus, 0.1)`;
                            }
                            
                            if (!sceneInitialized) {
                                newSceneCode += `            float scene = ${torusObj};\n`;
                                sceneInitialized = true;
                            } else {
                                newSceneCode += `            scene = opSmoothUnion(scene, ${torusObj}, ${this.currentSmoothness.toFixed(2)});\n`;
                            }
                        }
                        
                        // Second pass: apply all subtractive objects
                        if (this.showSphere.checked && this.subtractSphere.checked) {
                            let sphereObj = "sphere";
                            if (this.thicknessSphere.checked) {
                                sphereObj = `opThickness(sphere, 0.1)`;
                            }
                            newSceneCode += `            scene = opSmoothSubtraction(scene, ${sphereObj}, ${this.currentSmoothness.toFixed(2)});\n`;
                        }
                        
                        if (this.showBox.checked && this.subtractBox.checked) {
                            let boxObj = "box";
                            if (this.thicknessBox.checked) {
                                boxObj = `opThickness(box, 0.1)`;
                            }
                            newSceneCode += `            scene = opSmoothSubtraction(scene, ${boxObj}, ${this.currentSmoothness.toFixed(2)});\n`;
                        }
                        
                        if (this.showTorus.checked && this.subtractTorus.checked) {
                            let torusObj = "torus";
                            if (this.thicknessTorus.checked) {
                                torusObj = `opThickness(torus, 0.1)`;
                            }
                            newSceneCode += `            scene = opSmoothSubtraction(scene, ${torusObj}, ${this.currentSmoothness.toFixed(2)});\n`;
                        }
                    }
                    
                    // Combine the parts
                    const newSource = originalSource.substring(0, startIndex) + 
                               newSceneCode +
                               originalSource.substring(endIndex);
                    
                    this.needsRecompile = false;
                    return newSource;
                }
            };
            
            // Main application
            const app = {
                init: function() {
                    // Initialize components
                    if (!renderer.init()) return;
                    camera.init(renderer.canvas);
                    scene.init();
                    
                    // Get shader sources
                    const vsSource = document.getElementById('vertex-shader').text;
                    let fsSource = document.getElementById('fragment-shader').text;
                    
                    // Create initial shader program
                    renderer.createShaderProgram(vsSource, fsSource);
                    
                    // Start the render loop
                    this.render();
                },
                
                render: function() {
                    // Check if shader needs to be updated
                    const newShaderCode = scene.generateShaderCode();
                    if (newShaderCode) {
                        const vsSource = document.getElementById('vertex-shader').text;
                        renderer.createShaderProgram(vsSource, newShaderCode);
                    }
                    
                    // Render the scene
                    renderer.render();
                    
                    // Request next frame
                    requestAnimationFrame(() => this.render());
                }
            };
            
            // Start the application
            app.init();
        };
    </script>
</body>
</html> 