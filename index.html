<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Fragment Shader Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
        }
        canvas {
            display: block;
            flex: 1;
            width: 50vw;
            height: 100vh;
        }
        #ui-panel {
            width: 200px;
            background-color: rgba(30, 30, 40, 0.8);
            color: white;
            padding: 15px;
            font-family: Arial, sans-serif;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        #controls-info {
            margin-top: 20px;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div id="ui-panel">
        <div class="control-group">
            <h3>Objects</h3>
            <label><input type="checkbox" id="showSphere" checked> Sphere</label>
            <label><input type="checkbox" id="showBox" checked> Box</label>
            <label><input type="checkbox" id="showTorus" checked> Torus</label>
        </div>
        
        <div id="controls-info">
            <h3>Navigation</h3>
            <p>Shift + Mouse: Pan</p>
            <p>Alt + Mouse: Rotate</p>
            <p>Scroll: Zoom</p>
        </div>
    </div>

    <!-- Vertex shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aVertexPosition;
        
        void main() {
            gl_Position = aVertexPosition;
        }
    </script>

    <!-- Fragment shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform vec2 uResolution;
        uniform float uTime;
        uniform vec3 uCameraPosition;
        uniform mat3 uCameraRotation;
        
        // 3D SDF primitives
        float sdSphere(vec3 p, float r) {
            return length(p) - r;
        }
        
        float sdBox(vec3 p, vec3 b) {
            vec3 d = abs(p) - b;
            return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
        }
        
        float sdTorus(vec3 p, vec2 t) {
            vec2 q = vec2(length(p.xz) - t.x, p.y);
            return length(q) - t.y;
        }
        
        // SDF operations
        float opUnion(float d1, float d2) { return min(d1, d2); }
        float opSubtraction(float d1, float d2) { return max(-d1, d2); }
        float opIntersection(float d1, float d2) { return max(d1, d2); }
        
        // Smooth blend operations
        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) - k * h * (1.0 - h);
        }
        
        // Scene description
        float map(vec3 p) {
            // Animate objects
            vec3 spherePos = p - vec3(sin(uTime) * 1.5, cos(uTime * 0.5), 0.0);
            vec3 boxPos = p - vec3(0.0, sin(uTime) * 0.5, cos(uTime) * 1.5);
            vec3 torusPos = p - vec3(cos(uTime * 0.7) * 1.0, 0.0, sin(uTime * 0.5) * 1.0);
            
            // Create objects
            float sphere = sdSphere(spherePos, 1.0);
            float box = sdBox(boxPos, vec3(0.75));
            float torus = sdTorus(torusPos, vec2(1.0, 0.3));
            
            // Combine objects
            float scene = opSmoothUnion(sphere, box, 0.5);
            scene = opSmoothUnion(scene, torus, 0.5);
            
            // Add ground plane
            float ground = p.y + 1.5;
            scene = opUnion(scene, ground);
            
            return scene;
        }
        
        // Calculate normal at a point
        vec3 calcNormal(vec3 p) {
            const float eps = 0.001;
            const vec2 h = vec2(eps, 0.0);
            return normalize(vec3(
                map(p + h.xyy) - map(p - h.xyy),
                map(p + h.yxy) - map(p - h.yxy),
                map(p + h.yyx) - map(p - h.yyx)
            ));
        }
        
        // Ray marching
        float rayMarch(vec3 ro, vec3 rd) {
            float t = 0.0;
            for (int i = 0; i < 100; i++) {
                vec3 p = ro + rd * t;
                float d = map(p);
                if (d < 0.001 || t > 20.0) break;
                t += d;
            }
            return t;
        }
        
        void main() {
            // Normalized coordinates (0.0 to 1.0)
            vec2 uv = gl_FragCoord.xy / uResolution.xy;
            
            // Convert to centered coordinates (-1.0 to 1.0)
            vec2 p = (2.0 * uv - 1.0);
            // Correct aspect ratio
            p.x *= uResolution.x / uResolution.y;
            
            // Camera setup
            vec3 ro = uCameraPosition; // Ray origin (camera position)
            vec3 rd = normalize(uCameraRotation * vec3(p, 2.0)); // Ray direction
            
            // Ray march to find distance
            float t = rayMarch(ro, rd);
            
            // Default background color
            vec3 color = vec3(0.1, 0.1, 0.2);
            
            // If we hit something
            if (t < 20.0) {
                // Calculate hit position and normal
                vec3 pos = ro + rd * t;
                vec3 normal = calcNormal(pos);
                
                // Simple lighting
                vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Base color based on normal
                vec3 objColor = 0.5 + 0.5 * normal;
                
                // Add some color variation based on position
                objColor *= 0.8 + 0.2 * vec3(
                    0.5 + 0.5 * sin(pos.x * 2.0 + uTime),
                    0.5 + 0.5 * sin(pos.y * 2.0 + uTime * 0.7),
                    0.5 + 0.5 * sin(pos.z * 2.0 + uTime * 0.5)
                );
                
                // Apply lighting
                color = objColor * (0.2 + 0.8 * diff);
                
                // Add ambient occlusion
                float ao = 1.0 - (1.0 / (1.0 + t * 0.1));
                color *= ao;
            }
            
            // Apply gamma correction
            color = pow(color, vec3(0.4545));
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // Initialize WebGL when the page loads
        window.onload = function() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');
            
            // Object visibility controls
            const showSphere = document.getElementById('showSphere');
            const showBox = document.getElementById('showBox');
            const showTorus = document.getElementById('showTorus');
            
            // Track if shader needs to be recompiled
            let needsRecompile = false;
            
            // Camera state
            const camera = {
                position: [0.0, 0.0, -5.0],
                rotation: [0.0, 0.0, 0.0], // Euler angles in radians
                zoom: 5.0,
                autoRotate: true
            };
            
            // Mouse state
            const mouse = {
                lastX: 0,
                lastY: 0,
                dragging: false,
                shiftKey: false,
                altKey: false
            };
            
            // Add event listeners to checkboxes
            showSphere.addEventListener('change', () => { needsRecompile = true; });
            showBox.addEventListener('change', () => { needsRecompile = true; });
            showTorus.addEventListener('change', () => { needsRecompile = true; });
            
            // Add mouse and keyboard event listeners for navigation
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('wheel', handleMouseWheel);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            function handleMouseDown(event) {
                mouse.lastX = event.clientX;
                mouse.lastY = event.clientY;
                mouse.dragging = true;
            }
            
            function handleMouseUp() {
                mouse.dragging = false;
            }
            
            function handleMouseMove(event) {
                // Update last position regardless of dragging state
                const deltaX = event.clientX - (mouse.lastX || event.clientX);
                const deltaY = event.clientY - (mouse.lastY || event.clientY);
                
                // FreeCAD style: modifier key + mouse movement (no click required)
                if (mouse.shiftKey) {
                    // Pan (translate camera)
                    const panSpeed = -0.01;
                    // Calculate right and up vectors based on current rotation
                    const cosY = Math.cos(camera.rotation[1]);
                    const sinY = Math.sin(camera.rotation[1]);
                    
                    // Move right/left
                    camera.position[0] += deltaX * panSpeed * cosY;
                    camera.position[2] += deltaX * panSpeed * sinY;
                    
                    // Move up/down
                    camera.position[1] -= deltaY * panSpeed;
                    
                    // Disable auto-rotation when user pans
                    camera.autoRotate = false;
                }
                
                if (mouse.altKey) {
                    // Rotate camera
                    const rotateSpeed = 0.005;
                    camera.rotation[1] += deltaX * rotateSpeed; // Yaw (left/right)
                    camera.rotation[0] += deltaY * rotateSpeed; // Pitch (up/down)
                    
                    // Clamp pitch to avoid flipping
                    camera.rotation[0] = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camera.rotation[0]));
                    
                    // Disable auto-rotation when user rotates
                    camera.autoRotate = false;
                }
                
                mouse.lastX = event.clientX;
                mouse.lastY = event.clientY;
            }
            
            function handleMouseWheel(event) {
                // Zoom in/out
                const zoomSpeed = 0.1;
                camera.zoom += Math.sign(event.deltaY) * zoomSpeed;
                
                // Clamp zoom to reasonable values
                camera.zoom = Math.max(1.0, Math.min(20.0, camera.zoom));
                
                // Update camera position based on zoom
                updateCameraPosition();
                
                // Disable auto-rotation when user zooms
                camera.autoRotate = false;
                
                event.preventDefault();
            }
            
            function handleKeyDown(event) {
                if (event.key === 'Shift') {
                    mouse.shiftKey = true;
                } else if (event.key === 'Alt' || event.key === 'Meta') {
                    mouse.altKey = true;
                    // More aggressive prevention for Firefox
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }
            
            function handleKeyUp(event) {
                if (event.key === 'Shift') {
                    mouse.shiftKey = false;
                } else if (event.key === 'Alt' || event.key === 'Meta') {
                    mouse.altKey = false;
                    // Also prevent default on key up
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }
            
            function updateCameraPosition() {
                // Calculate position based on spherical coordinates
                const direction = [
                    Math.sin(camera.rotation[1]) * Math.cos(camera.rotation[0]),
                    Math.sin(camera.rotation[0]),
                    Math.cos(camera.rotation[1]) * Math.cos(camera.rotation[0])
                ];
                
                // Only update position if auto-rotate is disabled
                if (!camera.autoRotate) {
                    camera.position = [
                        -direction[0] * camera.zoom,
                        -direction[1] * camera.zoom,
                        -direction[2] * camera.zoom
                    ];
                }
            }
            
            // Create rotation matrix from Euler angles
            function createRotationMatrix(angles) {
                const [pitch, yaw, roll] = angles;
                
                // Rotation matrices for each axis
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                const cosRoll = Math.cos(roll);
                const sinRoll = Math.sin(roll);
                
                // Combined rotation matrix (column-major for WebGL)
                return [
                    cosYaw * cosRoll, sinPitch * sinYaw * cosRoll - cosPitch * sinRoll, cosPitch * sinYaw * cosRoll + sinPitch * sinRoll,
                    cosYaw * sinRoll, sinPitch * sinYaw * sinRoll + cosPitch * cosRoll, cosPitch * sinYaw * sinRoll - sinPitch * cosRoll,
                    -sinYaw, sinPitch * cosYaw, cosPitch * cosYaw
                ];
            }

            // If WebGL is not available, show an error
            if (!gl) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }

            // Resize canvas to match window size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Compile shader from source
            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // Create shader program
            function createShaderProgram(vsSource, fsSource) {
                const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            // Get shader sources from script tags
            const vsSource = document.getElementById('vertex-shader').text;
            let fsSource = document.getElementById('fragment-shader').text;
            
            // Create shader program
            let shaderProgram = createShaderProgram(vsSource, fsSource);
            
            // Function to update fragment shader based on UI settings
            function updateFragmentShader() {
                if (!needsRecompile) return;
                
                // Get the original shader source
                let originalSource = document.getElementById('fragment-shader').text;
                
                // Find the scene combination part and replace it
                const sceneStartMarker = "// Combine objects";
                const sceneEndMarker = "// Add ground plane";
                
                let startIndex = originalSource.indexOf(sceneStartMarker);
                let endIndex = originalSource.indexOf(sceneEndMarker);
                
                if (startIndex !== -1 && endIndex !== -1) {
                    // Skip to the end of the start marker line
                    startIndex = originalSource.indexOf('\n', startIndex) + 1;
                    
                    // Build the new scene combination code
                    let newSceneCode = "            // Combine objects\n";
                    
                    // Initialize with a very large value if no objects are selected
                    if (!showSphere.checked && !showBox.checked && !showTorus.checked) {
                        newSceneCode += "            float scene = 1000.0; // No objects selected\n";
                    } else {
                        // Start with the first checked object
                        if (showSphere.checked) {
                            newSceneCode += "            float scene = sphere;\n";
                        } else if (showBox.checked) {
                            newSceneCode += "            float scene = box;\n";
                        } else if (showTorus.checked) {
                            newSceneCode += "            float scene = torus;\n";
                        }
                        
                        // Add remaining objects with smooth union
                        if (showSphere.checked && showBox.checked) {
                            newSceneCode += "            scene = opSmoothUnion(scene, box, 0.5);\n";
                        } else if (!showSphere.checked && showBox.checked && showTorus.checked) {
                            newSceneCode += "            scene = opSmoothUnion(scene, torus, 0.5);\n";
                        }
                        
                        if (showSphere.checked && showTorus.checked) {
                            if (!showBox.checked) {
                                newSceneCode += "            scene = opSmoothUnion(scene, torus, 0.5);\n";
                            } else {
                                newSceneCode += "            scene = opSmoothUnion(scene, torus, 0.5);\n";
                            }
                        }
                    }
                    
                    // Combine the parts
                    fsSource = originalSource.substring(0, startIndex) + 
                               newSceneCode +
                               originalSource.substring(endIndex);
                    
                    // Recompile the shader program
                    gl.deleteProgram(shaderProgram);
                    shaderProgram = createShaderProgram(vsSource, fsSource);
                    
                    // Update program info
                    programInfo.program = shaderProgram;
                    programInfo.attribLocations.vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
                    programInfo.uniformLocations.resolution = gl.getUniformLocation(shaderProgram, 'uResolution');
                    programInfo.uniformLocations.time = gl.getUniformLocation(shaderProgram, 'uTime');
                    programInfo.uniformLocations.cameraPosition = gl.getUniformLocation(shaderProgram, 'uCameraPosition');
                    programInfo.uniformLocations.cameraRotation = gl.getUniformLocation(shaderProgram, 'uCameraRotation');
                }
                
                needsRecompile = false;
            }
            
            // Create a square (two triangles) that covers the entire canvas
            const positions = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0
            ];
            
            // Create buffer and load vertex data
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            // Get attribute and uniform locations
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    resolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
                    time: gl.getUniformLocation(shaderProgram, 'uTime'),
                    cameraPosition: gl.getUniformLocation(shaderProgram, 'uCameraPosition'),
                    cameraRotation: gl.getUniformLocation(shaderProgram, 'uCameraRotation'),
                },
            };
            
            // Start time for animation
            const startTime = Date.now();
            
            // Render function
            function render() {
                // Check if shader needs to be updated
                updateFragmentShader();
                
                // Calculate time in seconds
                const currentTime = (Date.now() - startTime) / 1000;
                
                // Update camera if auto-rotate is enabled
                if (camera.autoRotate) {
                    camera.rotation[1] = currentTime * 0.3; // Yaw rotation
                    updateCameraPosition();
                }
                
                // Clear the canvas
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Use our shader program
                gl.useProgram(programInfo.program);
                
                // Set up vertex attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    2,          // 2 components per vertex
                    gl.FLOAT,   // data type
                    false,      // don't normalize
                    0,          // stride
                    0           // offset
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Set uniforms
                gl.uniform2f(programInfo.uniformLocations.resolution, canvas.width, canvas.height);
                gl.uniform1f(programInfo.uniformLocations.time, currentTime);
                gl.uniform3fv(programInfo.uniformLocations.cameraPosition, new Float32Array(camera.position));
                gl.uniformMatrix3fv(
                    programInfo.uniformLocations.cameraRotation, 
                    false, 
                    new Float32Array(createRotationMatrix(camera.rotation))
                );
                
                // Draw the square (as triangle strip)
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                // Request next frame
                requestAnimationFrame(render);
            }
            
            // Start rendering
            render();
        };
    </script>
</body>
</html> 