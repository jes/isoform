<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Fragment Shader Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
        }
        canvas {
            display: block;
            flex: 1;
            width: 50vw;
            height: 100vh;
        }
        #ui-panel {
            width: 200px;
            background-color: rgba(30, 30, 40, 0.8);
            color: white;
            padding: 15px;
            font-family: Arial, sans-serif;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div id="ui-panel">
        <div class="control-group">
            <h3>Objects</h3>
            <label><input type="checkbox" id="showSphere" checked> Sphere</label>
            <label><input type="checkbox" id="showBox" checked> Box</label>
            <label><input type="checkbox" id="showTorus" checked> Torus</label>
        </div>
        
        <div class="control-group">
            <h3>Parameters</h3>
            <label for="smoothness">Blend Smoothness: <span id="smoothnessValue">0.5</span></label>
            <input type="range" id="smoothness" min="0.00" max="2.0" step="0.01" value="0.5">
        </div>
        
        <div class="control-group">
            <h3>Navigation</h3>
            <p><strong>Rotate:</strong> Click and drag</p>
            <p><strong>Pan:</strong> Shift + drag</p>
            <p><strong>Zoom:</strong> Mouse wheel</p>
        </div>
    </div>

    <!-- Vertex shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aVertexPosition;
        
        void main() {
            gl_Position = aVertexPosition;
        }
    </script>

    <!-- Fragment shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform vec2 uResolution;
        uniform float uTime;
        uniform vec3 uCameraPosition;
        uniform vec3 uCameraTarget;
        uniform float uCameraZoom;
        uniform float uRotationX;
        uniform float uRotationY;
        
        // 3D SDF primitives
        float sdSphere(vec3 p, float r) {
            return length(p) - r;
        }
        
        float sdBox(vec3 p, vec3 b) {
            vec3 d = abs(p) - b;
            return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
        }
        
        float sdTorus(vec3 p, vec2 t) {
            vec2 q = vec2(length(p.xz) - t.x, p.y);
            return length(q) - t.y;
        }
        
        // SDF operations
        float opUnion(float d1, float d2) { return min(d1, d2); }
        float opSubtraction(float d1, float d2) { return max(-d1, d2); }
        float opIntersection(float d1, float d2) { return max(d1, d2); }
        
        // Smooth blend operations
        float opSmoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) - k * h * (1.0 - h);
        }
        
        // Apply rotation to a point
        vec3 rotatePoint(vec3 p) {
            // Rotate around Y axis
            float cosY = cos(uRotationY);
            float sinY = sin(uRotationY);
            p = vec3(
                p.x * cosY - p.z * sinY,
                p.y,
                p.x * sinY + p.z * cosY
            );
            
            // Rotate around X axis
            float cosX = cos(uRotationX);
            float sinX = sin(uRotationX);
            p = vec3(
                p.x,
                p.y * cosX - p.z * sinX,
                p.y * sinX + p.z * cosX
            );
            
            return p;
        }
        
        // Scene description
        float map(vec3 p) {
            // Apply rotation to the point (effectively rotating the scene)
            p = rotatePoint(p);
            
            // Animate objects
            vec3 spherePos = p - vec3(sin(uTime) * 1.5, cos(uTime * 0.5), 0.0);
            vec3 boxPos = p - vec3(0.0, sin(uTime) * 0.5, cos(uTime) * 1.5);
            vec3 torusPos = p - vec3(cos(uTime * 0.7) * 1.0, 0.0, sin(uTime * 0.5) * 1.0);
            
            // Create objects
            float sphere = sdSphere(spherePos, 1.0);
            float box = sdBox(boxPos, vec3(0.75));
            float torus = sdTorus(torusPos, vec2(1.0, 0.3));
            
            // Combine objects
            float scene = opSmoothUnion(sphere, box, 0.5);
            scene = opSmoothUnion(scene, torus, 0.5);
            // Add ground plane
            
            return scene;
        }
        
        // Calculate normal at a point
        vec3 calcNormal(vec3 p) {
            const float eps = 0.001;
            const vec2 h = vec2(eps, 0.0);
            return normalize(vec3(
                map(p + h.xyy) - map(p - h.xyy),
                map(p + h.yxy) - map(p - h.yxy),
                map(p + h.yyx) - map(p - h.yyx)
            ));
        }
        
        // Ray marching
        float rayMarch(vec3 ro, vec3 rd) {
            float t = 0.0;
            for (int i = 0; i < 100; i++) {
                vec3 p = ro + rd * t;
                float d = map(p);
                if (d < 0.001 || t > 20.0) break;
                t += d;
            }
            return t;
        }
        
        void main() {
            // Normalized coordinates (0.0 to 1.0)
            vec2 uv = gl_FragCoord.xy / uResolution.xy;
            
            // Convert to centered coordinates (-1.0 to 1.0)
            vec2 p = (2.0 * uv - 1.0);
            // Correct aspect ratio
            p.x *= uResolution.x / uResolution.y;
            
            // Camera setup
            vec3 ro = uCameraPosition; // Ray origin (camera position)
            vec3 target = uCameraTarget; // Look at point
            
            // Camera frame
            vec3 forward = normalize(target - ro);
            vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
            vec3 up = cross(forward, right);
            
            // Apply zoom
            float zoom = uCameraZoom;
            
            // Ray direction using camera frame
            vec3 rd = normalize(forward + p.x * right * zoom + p.y * up * zoom);
            
            // Ray march to find distance
            float t = rayMarch(ro, rd);
            
            // Default background color
            vec3 color = vec3(0.1, 0.1, 0.2);
            
            // If we hit something
            if (t < 20.0) {
                // Calculate hit position and normal
                vec3 pos = ro + rd * t;
                vec3 normal = calcNormal(pos);
                
                // Simple lighting
                vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Base color based on normal
                vec3 objColor = 0.5 + 0.5 * normal;
                
                // Add some color variation based on position
                objColor *= 0.8 + 0.2 * vec3(
                    0.5 + 0.5 * sin(pos.x * 2.0 + uTime),
                    0.5 + 0.5 * sin(pos.y * 2.0 + uTime * 0.7),
                    0.5 + 0.5 * sin(pos.z * 2.0 + uTime * 0.5)
                );
                
                // Apply lighting
                color = objColor * (0.2 + 0.8 * diff);
                
                // Add ambient occlusion
                float ao = 1.0 - (1.0 / (1.0 + t * 0.1));
                color *= ao;
            }
            
            // Apply gamma correction
            color = pow(color, vec3(0.4545));
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // Initialize WebGL when the page loads
        window.onload = function() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');
            
            // Object visibility controls
            const showSphere = document.getElementById('showSphere');
            const showBox = document.getElementById('showBox');
            const showTorus = document.getElementById('showTorus');
            
            // Track if shader needs to be recompiled
            let needsRecompile = false;
            
            // Camera state
            const camera = {
                position: [0.0, 0.0, -5.0],
                target: [0.0, 0.0, 0.0],
                zoom: 1.0,
                // Scene rotation
                rotationX: 0.0,
                rotationY: 0.0,
                // For mouse interaction
                isDragging: false,
                lastMouseX: 0,
                lastMouseY: 0,
                // Mouse sensitivity
                rotationSpeed: 0.01,
                zoomSpeed: 0.1,
                panSpeed: 0.01
            };
            
            // Mouse event handlers
            canvas.addEventListener('mousedown', (e) => {
                camera.isDragging = true;
                camera.lastMouseX = e.clientX;
                camera.lastMouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => {
                camera.isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                camera.isDragging = false;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!camera.isDragging) return;
                
                const deltaX = e.clientX - camera.lastMouseX;
                const deltaY = e.clientY - camera.lastMouseY;
                
                if (e.shiftKey) {
                    // Pan camera in screen space
                    const panX = -deltaX * camera.panSpeed;
                    const panY = deltaY * camera.panSpeed;
                    
                    camera.target[0] += panX;
                    camera.target[1] += panY;
                    camera.position[0] += panX;
                    camera.position[1] += panY;
                } else {
                    // Rotate the scene (not the camera)
                    camera.rotationY += deltaX * camera.rotationSpeed;
                    camera.rotationX += deltaY * camera.rotationSpeed;
                }
                
                camera.lastMouseX = e.clientX;
                camera.lastMouseY = e.clientY;
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                // Adjust zoom based on wheel direction
                const zoomDelta = e.deltaY * camera.zoomSpeed * 0.01;
                camera.zoom += zoomDelta;
                
                // Clamp zoom to reasonable values
                camera.zoom = Math.max(0.1, Math.min(2.0, camera.zoom));
            });
            
            // Add event listeners to checkboxes
            showSphere.addEventListener('change', () => { needsRecompile = true; });
            showBox.addEventListener('change', () => { needsRecompile = true; });
            showTorus.addEventListener('change', () => { needsRecompile = true; });

            // If WebGL is not available, show an error
            if (!gl) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }

            // Resize canvas to match window size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Compile shader from source
            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // Create shader program
            function createShaderProgram(vsSource, fsSource) {
                const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            // Get shader sources from script tags
            const vsSource = document.getElementById('vertex-shader').text;
            let fsSource = document.getElementById('fragment-shader').text;
            
            // Create shader program
            let shaderProgram = createShaderProgram(vsSource, fsSource);
            
            // Function to update fragment shader based on UI settings
            function updateFragmentShader() {
                if (!needsRecompile && !smoothnessChanged) return;
                
                // Get the original shader source
                let originalSource = document.getElementById('fragment-shader').text;
                
                // Find the scene combination part and replace it
                const sceneStartMarker = "// Combine objects";
                const sceneEndMarker = "// Add ground plane";
                
                let startIndex = originalSource.indexOf(sceneStartMarker);
                let endIndex = originalSource.indexOf(sceneEndMarker);
                
                if (startIndex !== -1 && endIndex !== -1) {
                    // Skip to the end of the start marker line
                    startIndex = originalSource.indexOf('\n', startIndex) + 1;
                    
                    // Build the new scene combination code
                    let newSceneCode = "            // Combine objects\n";
                    
                    // Initialize with a very large value if no objects are selected
                    if (!showSphere.checked && !showBox.checked && !showTorus.checked) {
                        newSceneCode += "            float scene = 1000.0; // No objects selected\n";
                    } else {
                        // Start with the first checked object
                        let firstObjectAdded = false;
                        
                        if (showSphere.checked) {
                            newSceneCode += "            float scene = sphere;\n";
                            firstObjectAdded = true;
                        } else if (showBox.checked) {
                            newSceneCode += "            float scene = box;\n";
                            firstObjectAdded = true;
                        } else if (showTorus.checked) {
                            newSceneCode += "            float scene = torus;\n";
                            firstObjectAdded = true;
                        }
                        
                        // Add remaining objects with smooth union
                        if (firstObjectAdded && showBox.checked && !newSceneCode.includes("scene = box")) {
                            newSceneCode += `            scene = opSmoothUnion(scene, box, ${currentSmoothness.toFixed(2)});\n`;
                        }
                        
                        if (firstObjectAdded && showTorus.checked && !newSceneCode.includes("scene = torus")) {
                            newSceneCode += `            scene = opSmoothUnion(scene, torus, ${currentSmoothness.toFixed(2)});\n`;
                        }
                    }
                    
                    // Combine the parts
                    fsSource = originalSource.substring(0, startIndex) + 
                               newSceneCode +
                               originalSource.substring(endIndex);
                    
                    // Recompile the shader program
                    gl.deleteProgram(shaderProgram);
                    shaderProgram = createShaderProgram(vsSource, fsSource);
                    
                    // Update program info
                    programInfo.program = shaderProgram;
                    programInfo.attribLocations.vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
                    programInfo.uniformLocations.resolution = gl.getUniformLocation(shaderProgram, 'uResolution');
                    programInfo.uniformLocations.time = gl.getUniformLocation(shaderProgram, 'uTime');
                    programInfo.uniformLocations.cameraPosition = gl.getUniformLocation(shaderProgram, 'uCameraPosition');
                    programInfo.uniformLocations.cameraTarget = gl.getUniformLocation(shaderProgram, 'uCameraTarget');
                    programInfo.uniformLocations.cameraZoom = gl.getUniformLocation(shaderProgram, 'uCameraZoom');
                    programInfo.uniformLocations.rotationX = gl.getUniformLocation(shaderProgram, 'uRotationX');
                    programInfo.uniformLocations.rotationY = gl.getUniformLocation(shaderProgram, 'uRotationY');
                }
                
                needsRecompile = false;
                smoothnessChanged = false;
            }
            
            // Create a square (two triangles) that covers the entire canvas
            const positions = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0
            ];
            
            // Create buffer and load vertex data
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            // Get attribute and uniform locations
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    resolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
                    time: gl.getUniformLocation(shaderProgram, 'uTime'),
                    cameraPosition: gl.getUniformLocation(shaderProgram, 'uCameraPosition'),
                    cameraTarget: gl.getUniformLocation(shaderProgram, 'uCameraTarget'),
                    cameraZoom: gl.getUniformLocation(shaderProgram, 'uCameraZoom'),
                    rotationX: gl.getUniformLocation(shaderProgram, 'uRotationX'),
                    rotationY: gl.getUniformLocation(shaderProgram, 'uRotationY')
                },
            };
            
            // Start time for animation
            const startTime = Date.now();
            
            // Render function
            function render() {
                // Check if shader needs to be updated
                updateFragmentShader();
                
                // Calculate time in seconds
                const currentTime = (Date.now() - startTime) / 1000;
                
                // Clear the canvas
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Use our shader program
                gl.useProgram(programInfo.program);
                
                // Set up vertex attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    2,          // 2 components per vertex
                    gl.FLOAT,   // data type
                    false,      // don't normalize
                    0,          // stride
                    0           // offset
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Set uniforms
                gl.uniform2f(programInfo.uniformLocations.resolution, canvas.width, canvas.height);
                gl.uniform1f(programInfo.uniformLocations.time, currentTime);
                gl.uniform3fv(programInfo.uniformLocations.cameraPosition, camera.position);
                gl.uniform3fv(programInfo.uniformLocations.cameraTarget, camera.target);
                gl.uniform1f(programInfo.uniformLocations.cameraZoom, camera.zoom);
                gl.uniform1f(programInfo.uniformLocations.rotationX, camera.rotationX);
                gl.uniform1f(programInfo.uniformLocations.rotationY, camera.rotationY);
                
                // Draw the square (as triangle strip)
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                // Request next frame
                requestAnimationFrame(render);
            }
            
            // Start rendering
            render();
        };

        // Update smoothness value display when slider changes
        const smoothnessSlider = document.getElementById('smoothness');
        const smoothnessValue = document.getElementById('smoothnessValue');
        let currentSmoothness = parseFloat(smoothnessSlider.value);
        let smoothnessChanged = false;

        smoothnessSlider.addEventListener('input', () => {
            currentSmoothness = parseFloat(smoothnessSlider.value);
            smoothnessValue.textContent = currentSmoothness.toFixed(2);
            smoothnessChanged = true;
            needsRecompile = true; // Force shader recompilation when smoothness changes
        });
    </script>
</body>
</html> 